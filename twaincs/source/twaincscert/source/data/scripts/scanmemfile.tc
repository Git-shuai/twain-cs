;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scanmemfile v1.0 26-Feb-2020
; ${arg:1} - product name of scanner to open
; returns: pass or fail
;
; Scan with DAT_IMAGEMEMFILEXFER...
;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Init stuff...
;
setlocal twain.state '0'
setlocal index.twpendingxfers.count '0'
setlocal index.twsetupmemxfer.preferred '2'
setlocal image.pointer '0'
setlocal imagecount '0'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Load and open the DSM...
;
setlocal twain.state '1'
dsmload
echo 'dsmload'
setlocal twain.state '2'
dsmentry src null dg_control dat_parent msg_opendsm hwnd
echo 'parent/opendsm.............${sts:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
setlocal twain.state '3'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Open the driver...
;
dsmentry src null dg_control dat_identity msg_opends '0,0,0,ENGLISH_USA,USA,,2,4,0x0,,,${arg:1}'
echo 'identity/opends............${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
setlocal twain.state '4'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set ICAP_XFERMECH to TWSX_MEMFILE...
;
dsmentry src ds dg_control dat_capability msg_set 'ICAP_XFERMECH,TWON_ONEVALUE,TWTY_UINT16,TWSX_MEMFILE'
echo 'capability/set.............${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set ICAP_PIXELTYPE to TWPT_RGB
;
dsmentry src ds dg_control dat_capability msg_set 'ICAP_PIXELTYPE,TWON_ONEVALUE,TWTY_UINT16,TWPT_RGB'
echo 'capability/set.............${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set ICAP_COMPRESSION to TWCP_JPEG
;
dsmentry src ds dg_control dat_capability msg_set 'ICAP_COMPRESSION,TWON_ONEVALUE,TWTY_UINT16,TWCP_JPEG'
echo 'capability/set.............${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the preferred size for memory transfers, and allocate
; a pointer for the memory transfers...
;
dsmentry src ds dg_control dat_setupmemxfer msg_get '0,0,0'
echo 'setupmemxfer/get...........${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
setlocal twsetupmemxfer.preferred '${ret:${get:index.twsetupmemxfer.preferred}}'
if '${get:twsetupmemxfer.preferred}' <= '0' goto MAIN.FAIL
allocatepointer '${get:twsetupmemxfer.preferred}'
echo 'allocatepointer............${ret:} size=${get:twsetupmemxfer.preferred}'
if '${ret:}' == '0' goto MAIN.FAIL
setlocal image.pointer '${ret:}'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set DAT_SETUPFILEXFER to TWFF_TIFF
;
dsmentry src null dg_control dat_setupfilexfer msg_set 'file,TWFF_TIFF,0'
echo 'capability/set.............${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start scanning...
;
wait reset
dsmentry src ds dg_control dat_userinterface msg_enableds '0,0'
echo 'userinterface/enableds.....${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
setlocal twain.state '5'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Wait for MSG_XFERREADY, if we don't see it then scoot...
;
wait 30000
echo 'wait.......................${ret:}'
if '${ret:}' !~contains 'msg_xferready' goto MAIN.PASS



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Do a memory file transfer...
; This little song and dance with the states is so that we can
; start the transfer in state 6 with each new image, but switch
; to state 7 if we need multiple calls to capture the current
; image...
;
; The saved images will be in TIFF format, which includes TIFF
; JPEG (the better form, where a simple TIFF header is added).
;
:MAIN.NEXTIMAGEMEMFILEXFER.STATE6
setlocal twain.state '6'
increment imagecount '${get:imagecount}' 1
image free memfileimage
goto MAIN.NEXTIMAGEMEMFILEXFER
:MAIN.NEXTIMAGEMEMFILEXFER.STATE7
setlocal twain.state '7'
;
:MAIN.NEXTIMAGEMEMFILEXFER
dsmentry src ds dg_image dat_imagememfilexfer msg_get '0,0,0,0,0,0,0,3,${get:twsetupmemxfer.preferred},${get:image.pointer}'
echo 'imagememxfer/get...........${sts:} - ${ret:}'
if '${sts:}' == 'XFERDONE' goto MAIN.NEXTIMAGEMEMFILEXFER.XFERDONE
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
image append memfileimage '${ret:}'
goto MAIN.NEXTIMAGEMEMFILEXFER.STATE7
:MAIN.NEXTIMAGEMEMFILEXFER.XFERDONE
image append memfileimage '${ret:}'
image save memfileimage memfile '${folder:desktop}/twaincscert/img${format:D6|${get:imagecount}}'
setlocal twain.state '7'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End the transfer, see if we're done...
;
dsmentry src ds dg_control dat_pendingxfers msg_endxfer '0,0'
echo 'pendingxfers/endxfer.......${sts:} - ${ret:}'
if '${sts:}' != 'SUCCESS' goto MAIN.FAIL
if '${ret:${get:index.twpendingxfers.count}}' != '0' goto MAIN.NEXTIMAGEMEMFILEXFER.STATE6
image free memfileimage
setlocal twain.state '5'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; We've passed...
;
:MAIN.PASS
setlocal main.result pass
goto MAIN.EXIT



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; We're run into a problem...
;
:MAIN.FAIL
echo 'ERROR...........${sts:}'
image free memfileimage
setlocal main.result fail
goto MAIN.EXIT



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rewind the driver, close and unload the DSM, return...
;
:MAIN.EXIT
call TWAIN.REWIND
return '${get:main.result}'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Function: Rewind from any TWAIN state...
; returns: (nothing)
;
:TWAIN.REWIND
;
freepointer '${get:image.pointer)'
setlocal image.pointer '0'
if '${get:twain.state}' < '7' goto REWIND.6
dsmentry src ds dg_control dat_pendingxfers msg_endxfer '0,0'
echo 'pendingxfers/endxfer.......${sts:}'
setlocal twain.state '6'
:REWIND.6
if '${get:twain.state}' < '6' goto REWIND.5
dsmentry src ds dg_control dat_pendingxfers msg_reset '0,0'
echo 'pendingxfers/reset.........${sts:}'
setlocal twain.state '5'
:REWIND.5
if '${get:twain.state}' < '5' goto REWIND.4
dsmentry src ds dg_control dat_userinterface msg_disableds '0,0'
echo 'userinterface/disableds....${sts:}'
setlocal twain.state '4'
:REWIND.4
if '${get:twain.state}' < '4' goto REWIND.3
dsmentry src ds null dat_identity msg_closeds '0,0,0,ENGLISH_USA,USA,,2,4,0x0,,,${arg:1}'
echo 'identity/closeds...........${sts:}'
setlocal twain.state '3'
:REWIND.3
if '${get:twain.state}' < '3' goto REWIND.2
dsmentry src null dg_control dat_parent msg_closedsm hwnd
echo 'parent/closedsm............${sts:}'
setlocal twain.state '2'
:REWIND.2
if '${get:twain.state}' < '2' goto REWIND.1
dsmunload
echo 'dsmunload'
setlocal twain.state '1'
:REWIND.1
return
